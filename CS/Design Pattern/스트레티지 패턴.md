# 로봇 만들기
로봇 추상 클래스를 만들어 아톰과 태권V라는 클래스를 만든다. 각각 로봇은 움직이고 공격할  수 있는 수단을 가지고 있다. 그래서 아래의 코드로 작성한다.
### 기본 코드
```java
public abstarct class Robot {
	private String name;
	public Robot(String name){
		this.name = name;
	}
	public String getName(){
		return name;
	}
	public abstract void move();
	public abstract void attack();
}

public Atom extends Robot{
	public Atom(String name){
		super(name);
	}
	public void move(){
		System.out.println("move1");
	}
	public void attack(){
		System.out.println("attack1");
	}
}

public TaegwonV extends Robot{
	public TaegwonV(String name){
		super(name);
	}
	public void move(){
		System.out.println("move2");
	}
	public void attack(){
		System.out.println("attack2");
	}
}
```

해당 코드는 새로운 로봇은 계속해서 만들기는 쉽지만 새로운 move에 대한 기능을 변경할 때는 기존의 코드를 수정해야하여 OCP(개방폐쇄 원칙: 새로운 기능 추가를 위해 기존의 코드를 수정하지 않는 것)를 위반한다.

Robot이라는 추상 클래스를 통해 새로운 로봇을 추가하는 확장성이 확보되듯이 move와 attack를 위한 인터페이스를 만들어 상속 대신 집약 관계를 사용하는 것이 핵심이다. 

이렇게 인터페이스를 만들어 사용하면 인터페이스가 변한다 하더라도 Robot클래스의 변경을 차단해준다.
### 스트레티지 패턴을 적용한 코드
```java
public abstract class Robot {

	private String name;
	private MovingStrategy mvStrategy;
	private AttackStrategy atkStrategy;

	public Robot(String name){
		this.name = name;
	}
	public String getName(){
		return name;
	}
	public void setMovingStrategy(MovingStrategy s){
		mvStrategy = s;
	}
	public void setAttackStrategy(AttackStrategy a){
		atkStrategy = a;
	}
	public void move(){
		mvStrategy.move();
	}
	public void attack(){
		atkStrategy.attack();
	}
}
//로봇 인스턴스 생성을 위한 구체 클래스
public class TaekwonV extends Robot {
	public TaekwonV(String name){
		super(name);
	}
}

public class Attom extends Robot {
	public Attom(String name){
		super(name);
	}
}
// 행위 인터페이스
interface MovingStrategy(){
	public void move();
}

interface AttackStrategy(){
	public void attack();
}

public class FlyingStrategy implements MovingStrategy {
	public void move(){
		System.out.println("do fly");
	}
}
// 구체적인 행위 클래스
public class WalkStrategy implements MovingStrategy {
	public void move(){
		System.out.println("just walk");
	}
}
public class RocketPunchStrategy implements AttackStrategy{
	public void attack(){
		System.out.println("Both fists are launched");
	}
}
public class SwingBatStrategy implements AttackStrategy{
	public void attack(){
		System.out.println("Swing this steal bat");
	}
}
//실행
public class Client {
	public static void main(String[] args){
		Robot taekwonV = new TaekwonV("Mr.T");
		Robot attom = new Attom("Jr.A");

		taekwonV.setMovingStrategy(new WalkingStrategy());
		taekwonV.setAttackStrategy(new RocketPunchStrategy());
		attom.setMovingStrategy(new FlyingStrategy());
		attom.setAttackStrategy(new SwingBatStrategy());

		taekwonV.move();
		taekwonV.attack();
		
		attom.move();
		attom.attack();
	}
}

```

### 스트레티지 패턴의 목적
>[!hint] 목적
>같은 문제를 해결하는 방법이 여러 개이고 필요할 때 교체함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴이다.

#디자인패턴
#스트레티지패턴

